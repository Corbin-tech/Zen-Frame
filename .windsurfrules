### Code Style and Structure
- Write concise, technical Astro and Alpine code with accurate examples
- Use TypeScript to improve code quality when possible
- Use functional and declarative programming patterns; avoid classes
- Prefer iteration and modularization over code duplication
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError)

---

### Directories and Files
- Astro leverages an opinionated folder layout for your project. Every Astro project root should include the following directories and files:
  - **src/** – Your project source code (components, pages, styles, images, etc.)
  - **public/** – Your non-code, unprocessed assets (fonts, icons, etc.)
  - **package.json** – A project manifest
  - **astro.config.mjs** – An Astro configuration file (recommended)
  - **tsconfig.json** – A TypeScript configuration file (recommended)

- **Example Project Tree**:
  - **public/**
    - robots.txt
    - favicon.svg
    - my-cv.pdf
  - **src/**
    - blog/
      - post1.md
      - post2.md
      - post3.md
    - components/
      - Header.astro
      - Button.astro
    - images/
      - image1.jpg
      - image2.jpg
      - image3.jpg
    - layouts/
      - PostLayout.astro
    - pages/
      - posts/
        - post.astro
      - about.astro
      - index.astro
      - rss.xml.js
    - styles/
      - global.css
    - content.config.ts
  - astro.config.mjs
  - package.json
  - tsconfig.json

---

### Tech Stack
- **Astro** (Documentation: [https://docs.astro.build/en/getting-started/])
- **TypeScript**
- **Tailwind CSS** (Documentation: [https://tailwindcss.com/docs])
- **Flowbite** (A CSS component library) (Documentation: [https://flowbite.com/docs/getting-started/introduction/])
- **Alpine.js** (Documentation: [https://alpinejs.dev/start-here])
- **Pragmatic Drag and Drop** (Documentation: [https://atlassian.design/components/pragmatic-drag-and-drop/about])
- **Alpine UI** (Documentation: [https://alpinejs.dev/components])

---

### Naming Conventions
- Use lowercase with dashes for directories (e.g., `components/form-wizard`)
- Favor named exports for components and stores
- Use PascalCase for component files (e.g., `ZenQuote.astro`)
- Use camelCase for store files (e.g., `todoStore.ts`)
- Use kebab-case for all page files (e.g., `index.astro`)
- Use camelCase for all variables and function names

---

### Syntax and Formatting
- In `.astro` files, the main patterns are Astro templates + Alpine scripts
- We do not use React functional components unless explicitly stated
- Use the `function` keyword for pure functions
- Avoid unnecessary curly braces in conditionals
- Use double quotes for strings
- Implement proper TypeScript discriminated unions for message types
- Use proper Astro syntax with no JSX

---

### Astro Usage
- Use proper Astro syntax
- Avoid try/catch blocks unless there’s a good reason to translate or handle error in that abstraction
- Use explicit return types for all functions

---

### Additional Alpine Guidelines
- Only load Alpine.js **once** (via the official integration or a single `<script>`)
- Do not define multiple Alpine instances in the same codebase

---

### TypeScript Usage
- When possible, use TypeScript to improve code quality; prefer interfaces over types
- Enforce `tsconfig.json` strictness
- All generated code must comply with `tsconfig.json` settings (strict mode, noImplicitAny, strictNullChecks, etc.)
- Do not generate code that violates these settings or requires removing them
- Always include type annotations for parameters, return values, and variables where applicable
- Prefer explicit types or generics instead of `any`; if a library event or DOM type truly has no official typings, then `any` or `unknown` is acceptable
- Avoid enums; use const objects with `as const` assertion
- Avoid try/catch blocks for trivial code. Legitimate library calls, async/await, or external IO can use try/catch for error handling
- Use explicit return types for all functions

---

### Compile Checks
- Check to see if the code compiles before moving on
- Code must compile with the project’s `tsconfig.json` (strict mode, noImplicitAny, strictNullChecks). If a library lacks official typings, you may use `@types` packages or minimal type declarations
- If new code would cause a compile error, the code helper must rectify those errors in the solution
- If referencing types or interfaces not yet defined, the code helper must define them or import them from the correct file

---

### State Management
- Use Alpine Context for global state when needed (Alpine.js using `Alpine.store`)
- Implement proper cleanup in `useEffect` hooks

---

### UI and Styling
- Use Flowbite and Alpine UI for UI components
- Prioritize using Tailwind CSS for styling
- When adding a new component, document the installation command

---

### Error Handling
- Implement proper error boundaries
- Log errors appropriately for debugging
- Provide user-friendly error messages
- Handle network failures gracefully

---

### Testing
- Write unit tests for utilities and components
- Implement E2E tests for critical flows
- Test across different Chrome versions
- Test memory usage and performance

---

### Security
- Implement Content Security Policy
- Sanitize user inputs
- Handle sensitive data properly
- Implement proper CORS handling

---

### Documentation
- Maintain a clear README with setup instructions
- Document API interactions and data flows
- Provide simple comments in code on what functions do and for complex logic
- Document permission requirements

---

### Development Workflow
- Look at the entire codebase to maintain consistency
- If there’s a conflict between style rules and bug fixes, **prioritize** correct functional code first
- Ensure you do not create any redundancies in code
- Make sure all code is consistent
- Implement a proper code review process
- Test in multiple environments
- Never break any existing features or logic unless explicitly asked
